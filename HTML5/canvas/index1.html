<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        canvas{
            border:1px solid black;
            width: 200px;
            height:200px;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width=500 height=500></canvas>
    <script>
        var myCanvas = document.getElementById('myCanvas');
        var ctx = myCanvas.getContext('2d');
        // ctx.fillStyle = 'red';
        
        // ctx.shadowOffsetX = 10;
        // ctx.shadowOffsetY = 10;
        // ctx.shadowColor = 'grey';
        // ctx.shadowBlur = 10;
        // ctx.fillRect(0,0,100,100);

        // ctx.fillStyle = 'deeppink';        
        // ctx.font = '50px sans-serif';
        // ctx.textBaseline = 'middle';
        // ctx.textAlign = 'center';
        // ctx.fillText('dg',100,100);
        // ctx.strokeText('cc',250,250);

        //线段样式
        // ctx.moveTo(100,100);
        // ctx.lineTo(200,100);
        // ctx.lineWidth = 10;
        // ctx.stroke();

        // ctx.beginPath();
        // ctx.moveTo(100,150);
        // ctx.lineTo(200,150);
        // ctx.lineCap = 'round';

        // ctx.lineWidth=30;
        // ctx.stroke();
        // ctx.moveTo(100,100);
        // ctx.lineTo(200,100);
        // ctx.lineTo(50,130);
        // ctx.lineWidth = 30;
        // ctx.miterLimit = 20;
        // ctx.lineJoin = 'bevel';
        // ctx.lineJoin = 'round';
        // ctx.stroke();
        //剪裁
        // ctx.beginPath();
        // ctx.save();//保存当前状态
        // ctx.arc(250,250,100,0,Math.PI*2,0);//画圆
        // ctx.closePath();

        // ctx.clip();

        // ctx.fillRect(250,250,250,250);//只能在裁剪区域显示
        // ctx.restore();//恢复之前的状态
        // ctx.fillRect(0,0,100,100);

        //合成
        // ctx.fillStyle = 'red';
        // ctx.fillRect(200,200,100,100);//新像素
        
        // ctx.globalCompositeOperation = 'destination-over';//重叠显示方式

        // ctx.beginPath();
        // ctx.fillStyle = 'green';
        // ctx.arc(300,300,50,0,Math.PI*2,0);//旧像素
        // ctx.fill();
       
        // ctx.globalAlpha='0.5'//全局透明度

        //绘制图片
        // var oImg = new Image();
        // myImg.onload = function(){//图片加载完再执行
        //     ctx,drawImage(img,100,100,200,200,300,300,200,200);
        //     var data  = myCanvas.toDataURL();//抽取图片（同一服务器下）
        //     oImg.src = data;     
        //     document.body.appendChild(oImg);   
        // }
        // ctx.getImageData(x,y,dx,dy);//像素信息rgba
        // ctx.createImageDate(w,h)//创建IamgeData对象
        // ctx.putIamgeData(imageData,x,y)//将图像信息放到canvas画布上
        // //高斯函数 模糊图片，将ImageData传入函数，处理后返回新的ImageData，再画入canvas
        
        // ctx.moveTo(100,100);
        // ctx.lineTo(200,100);
        // ctx.lineTo(200,200);
        // ctx.closePath();
        // ctx.stroke();
        // console.log(ctx.isPointInPath(180,120));//判断点在不在canvas区域内
        // console.log(ctx.isPointInStroke(200,200));//判断是否在线上
        

        //如何解决canvas高分屏模糊问题：canvas绘制的是位图，会导致模糊
        //解决：根据分辨率修改canvas样式代码中的宽高与canvas的width height属性的比例
        // 把大画布塞到小相框里
        ctx.fillRect(100,100,300,300);
        
    </script>
</body>
</html>